## 进制相关

真值：123.45

$(123.45)_{10} = 1 * 10^{2} + 2 * 10^{1} + 3 * 10^0 + 4 * 10^{-1} + 5 * 10^{-2}$

$(1010.11)_2 = 1 * 2^3 + 0 * 2^2 + 1 * 2^1 + 0 * 2^0 + 1 * 2^{-1} + 1 * 2^{-2}  = 10.75$


- 数值中数据的表示

| 机器码 | 二进制 | 原码 | 反码 | 补码 | 移码 |
| :----: | :----: | :--: | :--: | :--: | ---- |
|  000   |   0    |  +0  |  +0  |  +0  | -4   |
|  001   |   1    |  +1  |  +1  |  +1  | -3   |
|  010   |   2    |  +2  |  +2  |  +2  | -2   |
|  011   |   3    |  +3  |  +3  |  +3  | -1   |
|  100   |   4    |  -0  |  -3  |  -4  | 0    |
|  101   |   5    |  -1  |  -2  |  -3  | 1    |
|  110   |   6    |  -2  |  -1  |  -2  | 2    |
|  111   |   7    |  -3  |  -0  |  -1  | 3    |

> 二进制中当一个数的字节长度为 n 时，表示有 $2^{n}$ 个数字，数字区间为 $0 \leq N \leq (2^{n-1} - 1)$

> 原码：最高位为符号位表示正（0）与负（1），表示 有 $2^n$ 个数字，数字 N 的区间为 $-(2^{n-1} - 1) \leq N \leq (2^{n-1} - 1)$
>
> 若字长为 3，表示区间则为 $-3 \leq n \leq 3$
> 零有两种表示方法 +0 -0

> 反码：正数与原码相同，负数为相对应正数按位取反(包含符号位)

> 补码：正数与原码相同，负数为其反码 +1 如超过字长，则舍弃字长最高位
>
> 补码的表示区间为 $-2^{n-1} \leq N \leq (2^{n-1} - 1)$
>
> 补码多出一位（上面的一 100）最高位可以看成负值，也可以表示数字，编码为 -4
>
> 计算机中采用补码进行运算 2 - 1 = 2 +（-1）= 010 + 111 = 1001 舍弃最高位 变成 001 也就是 +1

> 移码：补码的符号位取反 移码中符号位 0 为负数 ，1 为正数

$(10)_D = [0000 1010]_{原码} = [0000 1010]_{反码} = [0000 1010]_{补码} =[1000 1010]_{移码}$

$(-10)_D = [1000 1010]_{原码} = [1111 0101]_{反码} = [1111 0110]_{补码} = [0111 0110]_{移码}$


- 进制的运算
::: info
- 位运算符
  * & 按位与（AND） 两个操作数对应二进制位`都为1时`，其结果为1 类似于串联电路
  * | 按位或（OR）  两个操作数对应二进制位`只要有一个为1时`，其结果为1 类似于并联电路
  * ^ 按位异或（XOR） 两个操作数对应二进制位`只有一个为1时`，其结果才为1 相同为假，相异为真
  * ~ 按位非运算符(一元运算符) 二进制数（补码形式表示）==> 按位取反 ==> 原码 结果为 -(num + 1) 
- 位移运算符
  * '<<'  按位左移运算符 num * Math.pow(2, n)
  * '>>'  按位右移运算符 9 >> 2 = 4   Math.floor(4.5) ==> 4  Math.floor(-4.5) ==> 5
  * '>>>' 按位无符号右移运算符 
  :::

按位非 $(5)_D = [0000 0101]_{补码} = [1111 1010]_{补码-按位取反} ＝ [1111 1001]_{反码} ＝ [1000 0110]_{原码} ＝ －(5 + 1)$

按位非 $(－5)_D = [1000 0101]_{原码} = [1111 1010]_{反码} ＝ [1111 1011]_{补码} ＝ [0000 0100]_{补码－按位取反} ＝ －(－5 + 1)$

算术左移 $(28)_D = [0001 1100]_{原码} = [0011 1000]_{原码} = 56$

算术右移 $(28)_D = [0001 1100]_{原码} = [0000 1110]_{原码} = 14$

- JS 中进制的表示方法

```javascript
const num1 = 0b1000_0000 // 128
const num1 = 0200 // 128 严格模式下 0o200
const num3 = 0x80 // 128

// 相关运用 权限管理
const READ = 0b0001;
const CREATE = 0b0010;
const UPDATE = 0b0100;
const DELETE = 0b1000;

let permission = CREATE | UPDATE | DELETE; // 1110

console.log("permission :>> ", permission.toString(2));
console.log("添加权限 :>> ", (permission | READ).toString(2));

// 删除权限时，不能确定原本是否有这个权限，应该首先把权限添加上，再进行异或运算
console.log(((permission | READ) ^ READ).toString(2));
console.log("删除权限 :>> ", (permission ^ UPDATE).toString(2));

(permission & DELETE) === DELETE ? console.log("有删除权限") : console.log("无删除权限");

// 判断奇偶
console.log((11 & 1) === 1 ? '奇数' : '偶数')

// 交换变量
let a = 5,
  b = 3;

a = a ^ b;
b = a ^ b;
a = a ^ b;
console.log(a, b);
```



## IEEE 754 规范

$value = (-1)^{sign} * fraction_{binary} * 2 ^ {exponent_{binary} - 偏移值}$



| 符号位(1底数-1) |      指数位(11)      |   尾数位(52)   |                               |
| :-------------: | :------------------: | :------------: | ----------------------------- |
|      [0,1]      |         $0$          |      $0$       | $\pm 0$                       |
|      [0,1]      |          0           | $[1,2^{52}-1]$ | $非规约数_{偏移值1022 前导0}$ |
|      [0,1]      |      $[1,2046]$      | $[0,2^{52}-1]$ | $规约数_{偏移值1023 前导1}$   |
|      [0,1]      | $2047$$(即2^{11}-1)$ |      $0$       | $\pm \infty$                  |
|      [0,1]      | $2047$$(即2^{11}-1)$ | $[1,2^{52}-1]$ | $NaN$                         |

```js
/**
 * IEEE 754
 *
 * 规约化 偏移值 1023 指数! 全0 || 全1　尾数包含隐藏的1
 *
 * 特殊值
 * 指数     尾数
 * 全１     !全0 　 NaN
 * 全１     全０　  正负Infinity
 * 全０     全０　　正负0
 *
 * 非规约数 偏移值 1022　尾数不包含隐藏的1
 * 指数     尾数
 * 全0      !全０
 */

// 0 00000000000 0000000000000000000000000000000000000000000000000001 非规约数
console.log('最小值 :>> ', Number.MIN_VALUE === 1 * 2 ** (0b0 - 1022 - 52));

// 0 11111111110 1111111111111111111111111111111111111111111111111111
console.log(
  '最大值 :>> ',
  Number.MAX_VALUE === (2 ** 53 - 1) * 2 ** (0b11111111110 /** 2046 */ - 1023 - 52)
);

//  0 10000110011 1111111111111111111111111111111111111111111111111111
console.log(
  '最大安全值 :>> ',
  Number.MAX_SAFE_INTEGER === (2 ** 53 - 1) * 2 ** (0b10000110011 /** 1075 */ - 1023 - 52) /** 0 */
);

/**
 * 0 01111111111 0000000000000000000000000000000000000000000000000001 1.xxx
 * 0 01111111111 0000000000000000000000000000000000000000000000000000 1
 * 0 01111001011 0000000000000000000000000000000000000000000000000000 最小精度
 */
console.log(
  '最小精度 :>> ',
  Number.EPSILON === 1 * 2 ** (0b01111001011 /** 971 */ - 1023) /** -52 */
);

/**
 * 
 * 0.1 => 0.0_0011... => 1.1_0011... * (2 ** -4)
 * 符号位 0
 * 指数位 01111111011 => 1023 + -4 = 1019
 * 尾数位 1.1_0011_0011_0011_0011_0011_0011_0011_0011_0011_0011_0011_0011_010 精度丢失
 *
 * 0.2 => 0.0011... => 1.1_0011... * (2 ** -3)
 * 符号位 0
 * 指数位 01111111100 => 1023 + -3 = 1020
 * 尾数位 1.1_0011_0011_0011_0011_0011_0011_0011_0011_0011_0011_0011_0011_010 精度丢失
 *
 * 指数位不同调整 0.1 尾数右移
 * 符号位 0
 * 指数位 01111111100 => 1020
 * 尾数位 0.1100_1100_1100_1100_1100_1100_1100_1100_1100_1100_1100_1100_1101 右移一位精度丢失
 *
 * 0.1 + 0.2
 * 标准化尾数，省略前导0  0.1100110011001100110011001100110011001100110011001101 +
 * 标准化尾数，省略前导1  1.1001100110011001100110011001100110011001100110011010
 * 共53位说明进了一位    1.0110011001100110011001100110011001100110011001100111
 * 加上前导1           10.0110011001100110011001100110011001100110011001100111
 * 标准化尾数  1.0011001100110011001100110011001100110011001100110100 * 2 ** 1  左移一位 指数 +1 第三次丢失精度
 * 结果为     10011001100110011001100110011001100110011001100110100 * 2 ** (1020 + 1 - 1023 - 52)
 */

console.log(
  (
    0b1100110011001100110011001100110011001100110011001101 + 0b1001100110011001100110011001100110011001100110011010
  ).toString(2)
);

console.log(0b10011001100110011001100110011001100110011001100110100 * 2 ** (1021 - 1023 - 52) === 0.1 + 0.2);

/**
 *
 * @param {number} x
 * @param {number} y
 * @param {number} tolerance
 * @returns {boolean}
 */

function equal(x, y, tolerance = 1) {
  console.log(x, y, tolerance);
  return Math.abs(x - y) < tolerance * Number.EPSILON;
}

console.log(equal(0.1 + 0.2, 0.3));
console.log(equal(1000.1 + 1000.2, 2000.3, 2000));

```



## 体系结构

![Snipaste_2023-06-30_13-29-00](https://holger-picgo.oss-cn-beijing.aliyuncs.com/img/Snipaste_2023-06-30_13-29-00.png)

![TCPIP体系结构](https://holger-picgo.oss-cn-beijing.aliyuncs.com/img/TCPIP%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png)



## 应用层



## 运输层

运输层协议包含 `UDP` (用户数据报协议) 和 `TCP` (传输控制协议)

端口号：熟知端口号 1 - 1023 登记端口号 1024 - 49151 短暂端口号 49152 - 65535

`UDP` 将应用层交付的协议单元添加 `UDP` 首部（8 字节），直接打包，支持单播多播以及广播

`TCP` 将应用层交付的协议单元添加 `TCP` 首部（20-60 字节），面向字节流，三次握手，仅支持单播，点对点协议

- `TCP` 流量控制

> 一般来说，我们都希望数据传输的更快一些，但如果发送方把数据发送的过快，接收方可能来不及接收，这就会造成数据的丢失
>
> 所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收
>
> 利用滑动窗口机制，可以很方便地在 `TCP` 连接上实现对发送方的 [流量控制](https://www.bilibili.com/video/BV1c4411d7jb?p=60&spm_id_from=pageDriver&vd_source=cd7177f59ec8a3220f9a2f045d7e51c9&t=43.0)

- `TCP` 拥塞控制

> `TCP` 发送方的发送窗口取决于自身拥塞窗口和 `TCP` 接收方的接收窗口的最小值



## 网络层

#### 网络 `IP`

| 类别 | 网络标志位         | 最大网络数            | 可用 `IP` 地址范围        | 单个网段最大主机数       | 私有 `IP` 地址范围          |
| ---- | ------------------ | --------------------- | ------------------------- | ------------------------ | --------------------------- |
| A 类 | 0(网络号 8 位)     | 126$(2^7-2)$          | 1.0.0.1-127.255.255.254   | 16,777,214$(2^{24} - 2)$ | 10.0.0.0-10.255.255.255     |
| B 类 | 10(网络号 16 位)   | 16,384$(2^{14})$      | 128.0.0.1-191.255.255.254 | 65534$(2^{16} - 2)$      | 172.16.0.0-172.31.255.255   |
| C 类 | 110(网络号 24 位)  | 2,097,152($2^{21}$)   | 192.0.0.1-223.255.255.254 | 254$(2^8 -2)$            | 192.168.0.0-192.168.255.255 |
| D 类 | 1110(多播无网络号) | 268,435,456($2^{28}$) | 224.0.0.0-239.255.255.255 |                          |                             |
| E 类 | 11110（保留）      | 268,435,456($2^{28}$) | 240.0.0.0-255.255.255.255 |                          |                             |

> 主机号全 0 的地址是网络地址，主机号全 1 的地址是广播地址，都不能分配给主机或路由器各接口
>
> 最小网络号 0 为保留地址，不指派
>
> 地址 `0.0.0.0` 只能作为源地址使用，表示”在本网络上的主机“，封装有 `DHCP Discovery` 报文的 `IP` 分组的源地址使用 `0.0.0.0`
>
> 地址 `255.255.255.255` 只能作为目的地址使用，表示”只在本网络上进行广播（各路由器均不转发）“
>
> 在单个网段中 第一个为网络地址，最后一个为广播地址
>
> D 类与 E 类 `IPv4` 地址不区分网络地址与主机地址

![image-20221009114356984](https://holger-picgo.oss-cn-beijing.aliyuncs.com/img/image-20221009114356984.png)

A 类`IP`以 `0` 开始，最小为 0 $(0000 \ 0000)_2$ 最大为 127 $(0111 \ 1111)_2$ , 网络号 1 个字节，其中 0 代表任何地址，127 代表回环测试地址，因此 A 类地址的实际范围是 1-126。

B 类`IP`以 `10` 开始 最小为 128 $(1000 \ 0000 )_2$ 最大为 191 $(1011 \ 1111)_2$ ，网络号 2 个字节

C 类`IP`以 `110` 开始 最小为 192 $(1100 \ 0000)_2$ 最大为 223 $(1101 \ 1111)_2$ ，网络号 3 个字节

D 类`IP`以 `1110` 开始 最小为 224 $(1110 \ 0000)_2$ 最大为 239 $(1110 \ 1111)_2$不区分网络号与主机号

E 类`IP`以 `11110` 开始 最小为 240 $(1111 \ 0000)_2$ 最大为 247 $(1111 \ 0111)_2$ ，不区分网络号与主机号

例如：网络地址 `192.168.1.0/26` 可划分的子网数量为 4（$2^2$）个，每个子网可分配的地址数量为 64（$2^6$）个，子网掩码：`255.255.255.192` （根据 `CIDR` 可知第四字节前两位固定 $(1100 \ 0000)_2 = (192)_{10}$ ）

根据 `IP地址` `192.168.1.65`[^1]与 子网掩码 `255.255.255.192` [^2] 按位与[^与] 运算可得网络地址为 `192.168.1.64`[^3]

第一个网络地址：`192.168.1.0` 可分配 `IP` 地址 `192.168.1.1-192.168.1.62` 广播地址 `192.168.1.63`

第二个网络地址：`192.168.1.64` 可分配 `IP` 地址 `192.168.1.65-192.168.1.126` 广播地址 `192.168.1.127`

第一个网络地址：`192.168.1.128` 可分配 `IP` 地址 `192.168.1.129-192.168.1.190` 广播地址 `192.168.1.191`

#### ASCII 码规律

- 0 -31 及 127 为控制字符或通信专用字符（其余为可显示字符）
- 32 $(0010 \ 0000)_2$ 空格
- 48 $(0011 \ 0000)_2$ 数字 0-9
- 64 $(0100 \ 0000)_2$ @ A-Z
- 96 $(0110 \ 0000)_2$ ` a-z

### 排列组合（arrangement combination）

$$
排列数A_n^m=\underbrace{ n (n-1) (n-2) \cdots (n-m+1) }_{m个} = \frac {n!} {(n-m)!}
$$

[^1]: $(1100 \ 0000.1010 \ 1000.0000 \ 0001.0100 \ 0001)_2$
[^2]: $(1111 \ 1111.1111 \ 1111.1111 \ 1111.1100 \ 0000)_2$
[^3]: $(1100 \ 0000.1010 \ 1000.0000 \ 0001.0100 \ 0000)_2$
[^与]: 按位相与运算，当两边都是 1 时才是 1
